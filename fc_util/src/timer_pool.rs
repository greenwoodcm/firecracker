// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Implements a TimerFD pool.
// The goal here is to call timerfd_create() before applying the seccomp filter
// in order to not have to put it in the witelist.
// This implementation provides a flexbile way of creating the needed timer fd
// descriptors before starting the guest cpus and retrieving them anytime,
// including after Guest OS boot.

#![allow(non_upper_case_globals)]
use std::fmt::Formatter;
use std::sync::Mutex;
use timerfd::{ClockId, TimerFd};

/// Definition for a resource pool holding timer file descriptors.
pub struct TimerFdPool {
    // Monotonic timer fds.
    monotonic: Vec<TimerFd>,
}

/// Errors that generated by reserve_* or get_* methods.
pub enum TimerFdPoolError {
    /// Create_timerfd syscall failed, OS specific error specified.
    CreateFailed(i32),
    /// Pool is empty. (Maybe reserve() more timers)
    PoolEmpty,
}

impl std::fmt::Display for TimerFdPoolError {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use self::TimerFdPoolError::*;

        match self {
            CreateFailed(err) => write!(f, "Failed to create timer fd: {}.", err),
            PoolEmpty => write!(f, "Timer fd pool is empty."),
        }
    }
}

impl std::fmt::Debug for TimerFdPoolError {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use self::TimerFdPoolError::*;

        match self {
            CreateFailed(err) => write!(f, "Failed to create timer fd: {}.", err),
            PoolEmpty => write!(f, "Timer fd pool is empty."),
        }
    }
}

impl TimerFdPool {
    /// Returns a monotonic timer previously reserved using reserve_monotonic().
    pub fn get_monotonic(&mut self) -> Result<TimerFd, TimerFdPoolError> {
        self.monotonic.pop().ok_or(TimerFdPoolError::PoolEmpty)
    }

    /// Reserves a number of timer fds that can later acquired sequentially using get_monotonic().
    pub fn reserve_monotonic(&mut self, count: u16) -> Result<(), TimerFdPoolError> {
        for _ in 0..count {
            self.monotonic.push(
                TimerFd::new_custom(ClockId::Monotonic, true, true).map_err(|err| {
                    TimerFdPoolError::CreateFailed(err.raw_os_error().unwrap_or(0))
                })?,
            );
        }

        Ok(())
    }
}

lazy_static! {
    /// The timer pool as a Singleton.
    // This is not a global state object, it is a resource pool.
    pub static ref TimerPool: Mutex<TimerFdPool> = Mutex::new(TimerFdPool {
        monotonic: Vec::new(),
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pool() {
        assert!(TimerPool.lock().unwrap().reserve_monotonic(16).is_ok());

        for _ in 0..16 {
            assert!(TimerPool.lock().unwrap().get_monotonic().is_ok());
        }

        match TimerPool.lock().unwrap().get_monotonic() {
            Ok(_) => unreachable!(),
            Err(e) => assert_eq!(format!("{:?}", e), "Timer fd pool is empty."),
        }
    }
}
